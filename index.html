<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>ATIVIDADES PROCESSAMENTO DIGITAL DE IMAGENS</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
</head>
<body class="article">
<div id="header">
<h1>ATIVIDADES PROCESSAMENTO DIGITAL DE IMAGENS</h1>
</div>
<div id="content">
<div class="sect1 text-center">
<h2 id="_atividades_unidade_1">ATIVIDADES UNIDADE 1:</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1 text-center">
<h2 id="_manipulando_pixels_em_uma_imagem">MANIPULANDO PIXELS EM UMA IMAGEM</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_3_2_exercÍcio_1">3.2 - EXERCÍCIO 1:</h3>
<div class="sect3">
<h4 id="_regiões">Regiões:</h4>
<div class="literalblock text-left">
<div class="content">
<pre>Utilizando o programa exemplos/pixels.cpp como referência, implemente um programa regions.cpp. Esse programa deverá solicitar ao usuário as coordenadas de dois pontos P1P1 e P2P2 localizados dentro dos limites do tamanho da imagem e exibir que lhe for fornecida. Entretanto, a região definida pelo retângulo de vértices opostos definidos pelos pontos P1P1 e P2P2 será exibida com o negativo da imagem na região correspondente.</pre>
</div>
</div>
</div>
</div>
<div class="sect2 text-center">
<h3 id="_soluÇÃo">SOLUÇÃO:</h3>
<div class="paragraph">
<p>O exercício em questão foi feito utilizando-se da imagem abaixo:</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="imagem.jpg" alt="500" width="500">
</div>
</div>
<div class="paragraph">
<p>E após execução do algoritmo regions implementado obtivemos o resultado abaixo:</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="regions.png" alt="500" width="500">
</div>
</div>
<div class="listingblock text-left">
<div class="title">regions.cpp</div>
<div class="content">
<pre>#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string.h&gt;

using namespace std;
using namespace cv;

int main(int, char**){
  Mat image;
  Vec3b val;
  int x1,x2,y1,y2;

  image= imread("imagem.jpg",CV_LOAD_IMAGE_GRAYSCALE);

  cout &lt;&lt; "Digite P1 : ";
  cin &gt;&gt;  x1;
  cout &lt;&lt; "Digite P1 : ";
  cin &gt;&gt;  y1;
  cout &lt;&lt; "Digite P2 : ";
  cin &gt;&gt;  x2;
  cout &lt;&lt; "Digite P2 : ";
  cin &gt;&gt;  y2;

   for (int i = x1; i &lt; x2; ++i)
        {
             for (int j = y1; j &lt; y2; ++j)
             {
            image.at&lt;uchar&gt;(i,j) = 255 - image.at&lt;uchar&gt;(i,j);
         }
        }


  imshow("janela", image);
  waitKey();
  return 0;
}</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_3_2_exercÍcio_2">3.2 - EXERCÍCIO 2:</h3>
<div class="literalblock text-left">
<div class="content">
<pre>Utilizando o programa exemplos/pixels.cpp como referência, implemente um programa trocaregioes.cpp. Seu programa deverá trocar os quadrantes em diagonal na imagem. Explore o uso da classe Mat e seus construtores para criar as regiões que serão trocadas.</pre>
</div>
</div>
<div class="paragraph text-left">
<p>Após implementação e execução do programa trocaregioes.cpp foi obtido o resultado abaixo, já mostrando a imagem de entrada, a imagem em tons de cinza e a imagem com o efeito aplicado.</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="trocaregioes.png" alt="800" width="800">
</div>
</div>
<div class="paragraph">
<p>Código trocaregioes.cpp</p>
</div>
<div class="listingblock text-left">
<div class="title">trocaregioes.cpp</div>
<div class="content">
<pre>#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace cv;
using namespace std;

int px_1, py_1, px_2, py_2;
bool clicado = false;
Mat imgOriginal;
Mat imgGrayscale;
Mat imgResult;
Mat listOfRoi[4];


void pickARoi() {
    int index[4] = { 0,1,2,3 };

    srand(time(0));
    random_shuffle(begin(index), end(index));

    int ind1 = index[0];
    int ind2 = index[1];
    int ind3 = index[2];
    int ind4 = index[3];

    // imprimindo apenas para checar a ordem
   cout &lt;&lt; "\n\nOrdem : { " &lt;&lt; ind1 &lt;&lt; ", " &lt;&lt; ind2 &lt;&lt; ", " &lt;&lt; ind3 &lt;&lt; ", " &lt;&lt; ind4 &lt;&lt; " }\n\n";

    listOfRoi[ind1].copyTo(imgResult(Rect(0,                    0,                          listOfRoi[ind1].cols,   listOfRoi[ind1].rows)));
    listOfRoi[ind2].copyTo(imgResult(Rect(listOfRoi[ind1].cols, 0,                          listOfRoi[ind2].cols,   listOfRoi[ind2].rows)));
    listOfRoi[ind3].copyTo(imgResult(Rect(0,                    listOfRoi[ind1].rows,       listOfRoi[ind3].cols,   listOfRoi[ind3].rows)));
    listOfRoi[ind4].copyTo(imgResult(Rect(listOfRoi[ind1].cols, listOfRoi[ind1].rows,       listOfRoi[ind4].cols,   listOfRoi[ind4].rows)));
}

int main() {

    string arquivo;
    cout &lt;&lt; "Digite o nome do arquivo : ";
    cin &gt;&gt; arquivo;
    imgOriginal = imread(arquivo);

    if (imgOriginal.empty()) {
        cout &lt;&lt; "error: o arquivo --&gt; " &lt;&lt; arquivo &lt;&lt; " &lt;-- n„o pode ser lido!\n\n";
        system("pause");
        return(0);                                                                              // saindo do programa
    }

    cvtColor(imgOriginal, imgGrayscale, CV_BGR2GRAY);

    namedWindow("imgOriginal", CV_WINDOW_AUTOSIZE);
    namedWindow("imgGrayscale", CV_WINDOW_AUTOSIZE);
    namedWindow("imgResult", CV_WINDOW_AUTOSIZE);

    int col_half = imgOriginal.cols / 2;
    int row_half = imgOriginal.rows / 2;

    cout &lt;&lt; "\n\nWidth : " &lt;&lt; imgOriginal.cols &lt;&lt; "px\n";
    cout &lt;&lt; "Height : " &lt;&lt; imgOriginal.rows &lt;&lt; "px\n\n";

    Rect roi1(0,            0,          col_half,   row_half);
    Rect roi2(col_half,     0,          col_half,   row_half);
    Rect roi3(0,            row_half,   col_half,   row_half);
    Rect roi4(col_half,     row_half,   col_half,   row_half);

    listOfRoi[0] = Mat(imgGrayscale, roi1);
    listOfRoi[1] = Mat(imgGrayscale, roi2);
    listOfRoi[2] = Mat(imgGrayscale, roi3);
    listOfRoi[3] = Mat(imgGrayscale, roi4);

    imgResult = Mat(imgGrayscale.rows, imgGrayscale.cols, imgGrayscale.type());

    pickARoi();

    imshow("imgOriginal", imgOriginal);
    imshow("imgGrayscale", imgGrayscale);
    imshow("imgResult", imgResult);

    waitKey(0);
    return(0);
}</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 text-center">
<h2 id="_preenchendo_regiÕes">PREENCHENDO REGIÕES</h2>
<div class="sectionbody">
<div class="sect2 text-center">
<h3 id="_4_2_exercÍcios">4.2 - EXERCÍCIOS:</h3>
<div class="literalblock">
<div class="content">
<pre>1 - Observando-se o programa labeling.cpp como exemplo, é possível verificar que caso existam mais de 255 objetos na cena, o processo de rotulação poderá ficar comprometido. Identifique a situação em que isso ocorre e proponha uma solução para este problema.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>2 - Aprimore o algoritmo de contagem apresentado para identificar regiões com ou sem buracos internos que existam na cena. Assuma que objetos com mais de um buraco podem existir. Inclua suporte no seu algoritmo para não contar bolhas que tocam as bordas da imagem. Não se pode presumir, a priori, que elas tenham buracos ou não.</pre>
</div>
</div>
</div>
<div class="sect2 text-center">
<h3 id="_soluÇÃo_2">SOLUÇÃO:</h3>
<div class="paragraph text-left">
<p>1) Mesmo que o contador seja maior que os 255, só há como o computador representar 255 tons de cinza. Dessa forma, na forma como o programa labeling.cpp está implementado, depois que o contador ultrapassar o nível de cinza 255, todos os objetos que passarem pelo processamento do floodFill terão seus níveis de cinza iguais a 255.</p>
</div>
<div class="paragraph">
<p>Solução proposta para o problema:</p>
</div>
<div class="listingblock text-left">
<div class="title">contagem.cpp</div>
<div class="content">
<pre>#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main(int argc, char** argv){
    Mat image;
    int width, height;
    int contadorObjetos, tonDeCinza;

    CvPoint p;
    image = imread(argv[1],CV_LOAD_IMAGE_GRAYSCALE);

    if(!image.data){
        std::cout &lt;&lt; "imagem nao carregou corretamente\n";
        return(-1);
    }
    width=image.size().width;
    height=image.size().height;

    p.x=0;
    p.y=0;

    // busca objetos com buracos presentes
    tonDeCinza=0;
    contadorObjetos = 0;

    for(int i=0; i&lt;height; i++){
        for(int j=0; j&lt;width; j++){
          if(image.at&lt;uchar&gt;(i,j) == 255){
            // achou um objeto
            tonDeCinza++;
            contadorObjetos++;

            p.x=j;
            p.y=i;
            floodFill(image,p,tonDeCinza);

            if(tonDeCinza &gt;= 255)
                tonDeCinza = 0;
          }
        }
    }

    cout &lt;&lt; "Qtd. objetos: " &lt;&lt; contadorObjetos &lt;&lt; endl;

    imshow("image", image);
    waitKey();

    return 0;
}</pre>
</div>
</div>
<div class="paragraph text-left">
<p>2)Para a segunda parte do exercício foi implementado o programa abaixo em que ntes de tudo, desenhamos um retângulo com nível de cinza igual a 255 na borda da imagem. Depois disso, utilizamos a função floodFill no primeiro pixel da imagem mudando os valores dos tons dos pixels para zero. E com isso, os objetos que estavam em contato com esse retangulo foram imediatamente excluidos.</p>
</div>
<div class="listingblock text-left">
<div class="title">buracos.cpp</div>
<div class="content">
<pre>#include &lt;iostream&gt;
#include &lt;cv.h&gt;
#include "opencv2/highgui/highgui.hpp"
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main(int argc, char** argv){
    Mat image;
    int width, height;
    const int tonDeCinzaPreto = 0, tonDeCinzaBranco = 255;
    const int novaCorFundo = 100, novaCorObjeto = 200;
    int contadorObjetosSemBuraco, contadorObjetosComBuraco;

    CvPoint p;
    image = imread(argv[1],CV_LOAD_IMAGE_GRAYSCALE);

    if(!image.data){
        std::cout &lt;&lt; "imagem nao carregou corretamente\n";

        return(-1);
    }

    width = image.size().width;
    height = image.size().height;

    p.x = 0;
    p.y = 0;

    contadorObjetosSemBuraco = 0;
    contadorObjetosComBuraco = 0;

    Mat novaImagem = Mat::ones(width + 2, height + 2, CV_8U)*tonDeCinzaBranco;
    Mat(image, Rect(0, 0, width, height)).copyTo(Mat(novaImagem, Rect(1,1,width, height)));

    floodFill(novaImagem,p,tonDeCinzaPreto);

    floodFill(novaImagem,p,novaCorFundo);

    for(int i=0; i&lt;height; i++){
        for(int j=0; j&lt;width; j++){
            if(novaImagem.at&lt;uchar&gt;(i,j) == tonDeCinzaBranco){
                p.x=j;
                p.y=i;
                floodFill(novaImagem,p,novaCorObjeto);
                contadorObjetosSemBuraco++;
            }else if(novaImagem.at&lt;uchar&gt;(i,j) == tonDeCinzaPreto){
                p.x=j;
                p.y=i;
                floodFill(novaImagem,p,novaCorFundo);
                contadorObjetosComBuraco++;
            }
        }
    }

    p.x = 0;
    p.y = 0;
    floodFill(novaImagem,p,tonDeCinzaPreto);

    cout &lt;&lt; "Qtd. objetos: " &lt;&lt; contadorObjetosSemBuraco &lt;&lt; endl;
    cout &lt;&lt; "Qtd. objetos sem buraco: " &lt;&lt; contadorObjetosSemBuraco - contadorObjetosComBuraco &lt;&lt; endl;
    cout &lt;&lt; "Qtd. objetos com buraco: " &lt;&lt; contadorObjetosComBuraco &lt;&lt; endl;

    imshow("bolhas.png", image);

    imwrite("novaImagem.png", novaImagem);
    imshow("Nova Imagem", novaImagem);

    waitKey();
    return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>E após a execução do programa obemos o resultado abaixo:</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="resultbolhas.png" alt="800" width="800">
</div>
</div>
</div>
</div>
</div>
<div class="sect1 text-center">
<h2 id="_manipulaÇÃo_de_histogramas">MANIPULAÇÃO DE HISTOGRAMAS</h2>
<div class="sectionbody">
<div class="sect2 text-center">
<h3 id="_5_2_1_exercÍcio">5.2.1 - EXERCÍCIO:</h3>
<div class="literalblock text-left">
<div class="content">
<pre>Utilizando o programa exemplos/histogram.cpp como referência, implemente um programa equalize.cpp. Este deverá, para cada imagem capturada, realizar a equalização do histogram antes de exibir a imagem. Teste sua implementação apontando a câmera para ambientes com iluminações variadas e observando o efeito gerado. Assuma que as imagens processadas serão em tons de cinza.</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_soluÇÃo_3">SOLUÇÃO:</h3>
<div class="paragraph text-left">
<p>Para este primeiro problema exposto na parte de manipulação de histogramas, o programa utiliza da webcam do dispositivo em que está sendo executado, em que a captura dos frames é feito pela classe VideoCapture. A imagem capturada é então convertida para tons de cinza usando a função cvtColot(Mat, Mat, CV_BGR2GRAY) e essa imagem em tons de cinza tem é equalizada fazendo-se uso da função equalizeHist(Mat, Mat), que tem como entrada a imagem a ser equalizada e a imagem, ou elemento da classe Mat, que irá armazenar a imagem equalizada.</p>
</div>
<div class="listingblock text-left">
<div class="title">equalize.cpp</div>
<div class="content">
<pre>#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main(int argc, char** argv){
  Mat image;
  Mat equalizedImage;
  Mat imageGray;
  int width, height;
  //objeto de captura de frames
  VideoCapture cap;
  //vetor contendo as porcoes r g b da imagem
  vector&lt;Mat&gt; planes;
  //histogramas
  Mat histR, histG, histB;
  //tamanho do vetor histograma
  int nbins = 64;
  //parametros para calculo do histograma
  float range[] = {0, 256};
  const float *histrange = { range };
  bool uniform = true;
  bool acummulate = false;

  cap.open(0);//inicia objeto para captura de imagens

  //testa abertura
  if(!cap.isOpened()){
    cout &lt;&lt; "cameras indisponiveis";
    return -1;
  }

  //le altura e largura do frame sendo capturado
  width  = cap.get(CV_CAP_PROP_FRAME_WIDTH);
  height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);

  //mostra altura e largura na tela
  cout &lt;&lt; "largura = " &lt;&lt; width &lt;&lt; endl;
  cout &lt;&lt; "altura  = " &lt;&lt; height &lt;&lt; endl;

  //define largura e altura do histograma
  int histw = nbins, histh = nbins/2;
  //cria elemento para desenhar os histogramas
  Mat histImgR(histh, histw, CV_8UC3, Scalar(0,0,0));
  Mat histImgG(histh, histw, CV_8UC3, Scalar(0,0,0));
  Mat histImgB(histh, histw, CV_8UC3, Scalar(0,0,0));

  while(1){
    cap &gt;&gt; image;//transfere o frama capturado para o elemento tipo Mat
    split (image, planes);//divide os valores r,g e b em elementos diferentes
    //calcula histograma de cada elemento de cor
    calcHist(&amp;planes[0], 1, 0, Mat(), histR, 1,
             &amp;nbins, &amp;histrange,
             uniform, acummulate);
    calcHist(&amp;planes[1], 1, 0, Mat(), histG, 1,
             &amp;nbins, &amp;histrange,
             uniform, acummulate);
    calcHist(&amp;planes[2], 1, 0, Mat(), histB, 1,
             &amp;nbins, &amp;histrange,
             uniform, acummulate);
    //normaliza os histogramas
    normalize(histR, histR, 0, histImgR.rows, NORM_MINMAX, -1, Mat());
    normalize(histG, histB, 0, histImgR.rows, NORM_MINMAX, -1, Mat());
    normalize(histB, histB, 0, histImgR.rows, NORM_MINMAX, -1, Mat());

    //pinta os elementos dos histogramas todo de preto
    histImgR.setTo(Scalar(0));
    histImgG.setTo(Scalar(0));
    histImgB.setTo(Scalar(0));

    //desenha histograma
    for(int i=0; i&lt;nbins; i++){
      line(histImgR, Point(i, histh),
           Point(i, cvRound(histR.at&lt;float&gt;(i))),
           Scalar(0, 0, 255), 1, 8, 0);
      line(histImgG, Point(i, histh),
           Point(i, cvRound(histG.at&lt;float&gt;(i))),
           Scalar(0, 255, 0), 1, 8, 0);
      line(histImgB, Point(i, histh),
           Point(i, cvRound(histB.at&lt;float&gt;(i))),
           Scalar(255, 0, 0), 1, 8, 0);
    }
    histImgR.copyTo(image(Rect(0, 0       ,nbins, histh)));
    histImgG.copyTo(image(Rect(0, histh   ,nbins, histh)));
    histImgB.copyTo(image(Rect(0, 2*histh ,nbins, histh)));
    imshow("image", image);

    //converte imagem para tons de cinza
    cvtColor(image, imageGray, CV_BGR2GRAY);
    //equaliza a imagem em tons de cinza
    equalizeHist(imageGray, equalizedImage);

    imshow("Equalized Gray Image", equalizedImage);

    if(waitKey(27) &gt;= 0) break;
  }
  return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>E o resultado após a execução do programa está mostrado na imagem abaixo:</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="equalize.png" alt="800" width="800">
</div>
</div>
</div>
<div class="sect2 text-center">
<h3 id="_5_2_2_exercÍcio">5.2.2 - EXERCÍCIO:</h3>
<div class="literalblock text-left">
<div class="content">
<pre>Utilizando o programa exemplos/histogram.cpp como referência, implemente um programa motiondetector.cpp. Este deverá continuamente calcular o histograma da imagem (apenas uma componente de cor é suficiente) e compará-lo com o último histograma calculado. Quando a diferença entre estes ultrapassar um limiar pré-estabelecido, ative um alarme. Utilize uma função de comparação que julgar conveniente.</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_soluÇÃo_4">SOLUÇÃO:</h3>
<div class="paragraph text-left">
<p>O programa motiondetector.cpp, assim como o equalize.cpp utiliza a classe VidioCapturepara capturar imagens através de uma webcam disponível no dispositivo em que está sendo executada.</p>
</div>
<div class="listingblock text-left">
<div class="title">motiondetector.cpp</div>
<div class="content">
<pre>#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

int main(int argc, char** argv){
  Mat image;
  int width, height;
  VideoCapture cap;
  Mat hist, oldHist;
  int nbins = 64;
  float range[] = {0, 256};
  const float *histrange = { range };
  bool uniform = true;
  bool acummulate = false;
  cap.open(0);

  if(!cap.isOpened()){
    cout &lt;&lt; "cameras indisponiveis";
    return -1;
  }

  width  = cap.get(CV_CAP_PROP_FRAME_WIDTH);
  height = cap.get(CV_CAP_PROP_FRAME_HEIGHT);

  cout &lt;&lt; "largura = " &lt;&lt; width &lt;&lt; endl;
  cout &lt;&lt; "altura  = " &lt;&lt; height &lt;&lt; endl;

  int histw = nbins, histh = nbins/2;
  Mat histImg(histh, histw, CV_8UC1, Scalar(0));
  int count = 0;
  double histDiff = 0;

  while(1){
    cap &gt;&gt; image;
    cvtColor(image, image, CV_BGR2GRAY);

    calcHist(&amp;image, 1, 0, Mat(), hist, 1,
             &amp;nbins, &amp;histrange,
             uniform, acummulate);
    normalize(hist, hist, 0, histImg.rows, NORM_MINMAX, -1, Mat());

    histImg.setTo(Scalar(0));

    for(int i=0; i&lt;nbins; i++){
      line(histImg, Point(i, histh),
           Point(i, cvRound(hist.at&lt;float&gt;(i))),
           Scalar(255), 1, 8, 0);
   }

    histImg.copyTo(image(Rect(0, 0       ,nbins, histh)));
    imshow("image", image);

    if(count &gt;=1)
       histDiff = compareHist(hist, oldHist, 0);

    if( histDiff &lt; 0.98)
       cout &lt;&lt; "motion detected, histDiff = " &lt;&lt; histDiff &lt;&lt; endl;
    oldHist = hist.clone();
    count++;
    if(waitKey(30) &gt;= 0) break;
  }
  return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>Os resultados após execução do programa podem ser vistos nas imagens abaixo:</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="motion.png" alt="800" width="800">
</div>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="motion2.png" alt="800" width="800">
</div>
</div>
</div>
</div>
</div>
<div class="sect1 text-center">
<h2 id="_filtragem_no_domÍnio_espacial_i">FILTRAGEM NO DOMÍNIO ESPACIAL I</h2>
<div class="sectionbody">
<div class="sect2 text-center">
<h3 id="_6_2_exercÍcio">6.2 - EXERCÍCIO:</h3>
<div class="literalblock text-left">
<div class="content">
<pre>Utilizando o programa exemplos/filtroespacial.cpp como referência, implemente um programa laplgauss.cpp. O programa deverá acrescentar mais uma funcionalidade ao exemplo fornecido, permitindo que seja calculado o laplaciano do gaussiano das imagens capturadas. Compare o resultado desse filtro com a simples aplicação do filtro laplaciano.</pre>
</div>
</div>
</div>
<div class="sect2 text-center">
<h3 id="_soluÇÃo_5">SOLUÇÃO:</h3>
<div class="paragraph text-left">
<p>Para obter o resultado do laplaciano do gaussiano é necessário filtrar a imagem dada com um filtro gaussiano e, logo após, utilizar o filtro laplaciano no resultado da filtragem anterior.</p>
</div>
<div class="listingblock text-left">
<div class="title">lapgauss.cpp</div>
<div class="content">
<pre>#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;
using namespace std;

void printmask(Mat &amp;m){
  for(int i=0; i&lt;m.size().height; i++){
    for(int j=0; j&lt;m.size().width; j++){
      cout &lt;&lt; m.at&lt;float&gt;(i,j) &lt;&lt; ",";
    }
    cout &lt;&lt; endl;
  }
}

void menu(){
  cout &lt;&lt; "\npressione a tecla para ativar o filtro: \n"
  "a - calcular modulo\n"
    "m - media\n"
    "g - gauss\n"
    "v - vertical\n"
  "h - horizontal\n"
    "l - laplaciano\n"
    "x - laplaciano do gaussiano\n"
  "esc - sair\n";
}

int main(int argvc, char** argv){
  VideoCapture video;
  float media[] = {1,1,1,
           1,1,1,
           1,1,1};
  float gauss[] = {1,2,1,
           2,4,2,
           1,2,1};
  float horizontal[]={-1,0,1,
            -2,0,2,
            -1,0,1};
  float vertical[]={-1,-2,-1,
          0,0,0,
          1,2,1};
  float laplacian[]={0,-1,0,
           -1,4,-1,
           0,-1,0};

  Mat cap, frame, frame32f, frameFiltered, frameFiltered1;
  Mat mask(3,3,CV_32F), mask1;
  Mat result, result1;
  double width, height;
  int absolut;
  char key;
  bool laplgauss = false;

  video.open(0);
  if(!video.isOpened())
    return -1;

  width=video.get(CV_CAP_PROP_FRAME_WIDTH);
  height=video.get(CV_CAP_PROP_FRAME_HEIGHT);

  cout &lt;&lt; "largura=" &lt;&lt; width &lt;&lt; "\n";;
  cout &lt;&lt; "altura =" &lt;&lt; height&lt;&lt; "\n";;

  namedWindow("filtroespacial",1);

  mask = Mat(3, 3, CV_32F, media);
  scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
  swap(mask, mask1);
  absolut=1;

  menu();
  for(;;){
    video &gt;&gt; cap;
    cvtColor(cap, frame, CV_BGR2GRAY);
    flip(frame, frame, 1);
    imshow("original", frame);
    frame.convertTo(frame32f, CV_32F);

    if(laplgauss){
      mask = Mat(3, 3, CV_32F, gauss);
      scaleAdd(mask, 1/16.0, Mat::zeros(3,3,CV_32F), mask1);
      mask = mask1;
      filter2D(frame32f, frameFiltered, frame32f.depth(), mask, Point(1,1), 0);
      mask = Mat(3, 3, CV_32F, laplacian);
      filter2D(frameFiltered, frameFiltered1, frameFiltered.depth(), mask, Point(1,1), 0);

      if(absolut){
        frameFiltered1=abs(frameFiltered1);
      }

      frameFiltered1.convertTo(result1, CV_8U);
      imshow("filtroespacial", result1);
    }
    else{
      filter2D(frame32f, frameFiltered, frame32f.depth(), mask, Point(1,1), 0);

      if(absolut){
        frameFiltered=abs(frameFiltered);
      }

      frameFiltered.convertTo(result, CV_8U);
      imshow("filtroespacial", result);
    }

    key = (char) waitKey(10);
    if( key == 27 ) break; // esc pressed!
    switch(key){
    case 'a':
    laplgauss = false;
      menu();
      absolut=!absolut;
      break;
    case 'm':
      menu();
      mask = Mat(3, 3, CV_32F, media);
      scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
      mask = mask1;
      printmask(mask);
      laplgauss = false;

      break;
    case 'g':
      menu();
      mask = Mat(3, 3, CV_32F, gauss);
      scaleAdd(mask, 1/16.0, Mat::zeros(3,3,CV_32F), mask1);
      mask = mask1;
      printmask(mask);
      laplgauss = false;

      break;
    case 'h':
      menu();
      mask = Mat(3, 3, CV_32F, horizontal);
      printmask(mask);
      laplgauss = false;

      break;
    case 'v':
      menu();
      mask = Mat(3, 3, CV_32F, vertical);
      printmask(mask);
      laplgauss = false;

      break;
    case 'l':
      menu();
      mask = Mat(3, 3, CV_32F, laplacian);
      printmask(mask);
      laplgauss = false;

      break;
    case 'x':
     laplgauss = true;
     menu();

     break;
    default:
      break;
    }
  }
  return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>Após a execução do programa podemos obter os resultados abaixo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Imagem processada com o filtro laplaciano:</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="laplaciano.png" alt="600" width="600">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Imagem processada com o Lapgauss, em que podemos observar uma certa quantidade menor de ruido:</p>
</li>
</ul>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="lapgauss.png" alt="600" width="600">
</div>
</div>
</div>
</div>
</div>
<div class="sect1 text-center">
<h2 id="_filtragem_no_domÍnio_espacial_2">FILTRAGEM NO DOMÍNIO ESPACIAL 2</h2>
<div class="sectionbody">
<div class="sect2 text-center">
<h3 id="_7_2_1_exercÍcio">7.2.1 - EXERCÍCIO:</h3>
<div class="literalblock">
<div class="content">
<pre>Utilizando o programa exemplos/addweighted.cpp como referência, implemente um programa tiltshift.cpp. Três ajustes deverão ser providos na tela da interface:</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>-Um ajuste para regular a altura da região central que entrará em foco;
-Um ajuste para regular a força de decaimento da região borrada;
-Um ajuste para regular a posição vertical do centro da região que entrará em foco. Finalizado o programa, a imagem produzida deverá ser salva em arquivo.</pre>
</div>
</div>
</div>
<div class="sect2 text-center">
<h3 id="_soluÇÃo_6">SOLUÇÃO:</h3>
<div class="paragraph text-left">
<p>A técnica fotográfica de tilt-shift envolve o uso de deslocamentos e rotações entre a lente e o plano de projeção (onde fica filme fotográfico ou o sensor da câmera) de modo a desfocar seletivamente regiões do assunto.
A ideia é pegar a imagem original e somá-la com ela própia borrada, com as proporções adequadas para simular o efeito.
Foi utilizado o filtro da média, que gera o borramento. Para que efeito fique bastante evidente, o efeito foi aplicado 40 vezes.</p>
</div>
<div class="listingblock text-left">
<div class="title">tiltshift.cpp</div>
<div class="content">
<pre>#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;cmath&gt;

using namespace cv;
using namespace std;

int d_slider = 0;
int d_max = 100;

int sup_slider = 0;
int sup_max;

int inf_slider = 0;
int inf_max;

Mat original, borrada, final ;
Mat imageTop;

char TrackbarName[50];

double calcAlpha(double x, double l1, double l2, double d){
  return 0.5*(tanh((x-l1)/d) - tanh((x-l2)/d));
}

void blend(int, void*){
 for (int i = 0; i &lt; original.rows ; i++)
 {
   double alpha = calcAlpha(i,sup_slider,inf_slider,d_slider);
   addWeighted(original.row(i),alpha, borrada.row(i),1-alpha,0.0,final.row(i));
 }
 imshow("resultado", final);
 imwrite("resutTiltShift.jpg", final);
}

int main(int argvc, char** argv){

  original = imread("india.jpg");
  original.copyTo(borrada);
  original.copyTo(final);
  namedWindow("resultado", 1);

  float media[] = {1,1,1,
           1,1,1,
           1,1,1};
  Mat mask(3,3,CV_32F), mask1;

  mask = Mat(3, 3, CV_32F, media);
  scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
  mask = mask1;

  for (int i = 0; i &lt; 40; ++i)
  {
    filter2D(original, borrada, original.depth(), mask, Point(1,1), 0);
  }

  sup_max = original.rows;
  inf_max = original.rows;

  sprintf( TrackbarName, "Decaimento");
  createTrackbar( TrackbarName, "resultado",
          &amp;d_slider,
          d_max,
          blend );
  blend(d_slider, 0 );

  sprintf( TrackbarName, "Limite superior");
  createTrackbar( TrackbarName, "resultado",
          &amp;sup_slider,
          sup_max,
          blend);
  blend(sup_slider, 0 );

  sprintf( TrackbarName, "Limite inferior");
  createTrackbar( TrackbarName, "resultado",
          &amp;inf_slider,
          inf_max,
          blend );
  blend(inf_slider, 0 );


  waitKey(0);
  return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>Após a execução do programa, ele salva a imagem gerada automáticamente, e podemos ter como um resultado exemplo após ajuste dos parametros das trackbars a imagem abaixo:</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="resultadotilt.png" alt="600" width="600">
</div>
</div>
</div>
</div>
</div>
<div class="sect1 text-center">
<h2 id="_atividades_unidade_2">ATIVIDADES UNIDADE 2:</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1 text-center">
<h2 id="_filtragem_no_domÍnio_da_frequÊncia">FILTRAGEM NO DOMÍNIO DA FREQUÊNCIA</h2>
<div class="sectionbody">
<div class="sect2 text-center">
<h3 id="_8_2_exercÍcio">8.2 - EXERCÍCIO:</h3>
<div class="literalblock text-left">
<div class="content">
<pre>Utilizando o programa exemplos/dft.cpp como referência, implemente o filtro homomórfico para melhorar imagens com iluminação irregular. Crie uma cena mal iluminada e ajuste os parâmetros do filtro homomórfico para corrigir a iluminação da melhor forma possível. Assuma que a imagem fornecida é em tons de cinza.</pre>
</div>
</div>
</div>
<div class="sect2 text-center">
<h3 id="_soluÇÃo_7">SOLUÇÃO:</h3>
<div class="paragraph text-center">
<p><strong>Filtragem Homomórfica</strong></p>
</div>
<div class="paragraph text-left">
<p>A filtragem homomórfica trata-se basicamente de uma abordagem que opera sobre as componentes de iluminação e reflectância separadamente. Em que ela atenua as baixas-frequências e realça as altas.</p>
</div>
<div class="paragraph">
<p>Como mostrado na equação abaixo:</p>
</div>
<div class="paragraph text-center">
<p>\(f(x,y)=i(x,y)r(x,y)\)</p>
</div>
<div class="paragraph text-left">
<p>Em que esse método de filtragem é deduzido na seguinte imagem:</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="homomorfic.png" alt="500" width="500">
</div>
</div>
<div class="paragraph text-left">
<p>O filtro homomórfico funciona com a idéia de que a "iluminação" é a componente de baixa-frequência e a "reflectância" é a componente de alta-frequência. Onde aumenta-se o contraste se a iluminação é diminuida (i&lt;1) e a reflectância é aumentada (r&gt;1).
Nessa transição pode-se utilizar qualquer curva, mas geralmente utiliza-se Butterworth ou Gaussiano.</p>
</div>
<div class="paragraph text-left">
<p>Podemos ver na figura abaixo um corte transversal de um filtro como esse.</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="grafic.png" alt="500" width="500">
</div>
</div>
<div class="paragraph text-left">
<p>E logo abaixo temos também uma forma ligeiramente modificada do filtro passa-alta gaussiano.</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="formule.png" alt="500" width="500">
</div>
</div>
<div class="paragraph text-left">
<p>Abaixo temos o código de implementação do filtro:</p>
</div>
<div class="listingblock text-left">
<div class="title">homomorfic.cpp</div>
<div class="content">
<pre>#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;math.h&gt;

#define RADIUS 20

using namespace cv;
using namespace std;

Mat filter, tmp;
int dft_N, dft_M;
int dh_slider = 20;
int dh_slider_max = 100;

int dl_slider = 5;
int dl_slider_max = 100;

int c_slider = 5;
int c_slider_max = 100;

int d0_slider = 80;
int d0_slider_max = 1000;

char TrackbarName[50];

void slider(int, void*){
	int M,N;
	float D2, dh, dl, d0;
	M = dft_M;
	N = dft_N;
	dh = dh_slider/10.0;
	dl = dl_slider/10.0;
	d0 = d0_slider/10.0;
  //calculando o filtro homomorfico a partir do ajuste dos sliders da trackbar.
	tmp = Mat(dft_M, dft_N, CV_32F);
	for(int i=0; i&lt;dft_M ;i++)
		for(int j=0; j&lt;dft_N ;j++){
				D2 = ((float)i-M/2.0)*((float)i-M/2.0) + ((float)j-N/2.0)*((float)j-N/2.0);
				tmp.at&lt;float&gt;(i,j) = (dh-dl)*(1.0-exp(-1.0*(float)c_slider*(D2/(d0*d0))))+ dl;
			}

  // cria a matriz com as componentes do filtro e junta
  // ambas em uma matriz multicanal complexa
  Mat comps[]= {tmp, tmp};
  merge(comps, 2, filter);

}

// troca os quadrantes da imagem da DFT
void deslocaDFT(Mat&amp; image ){
  Mat A, B, C, D;

  // se a imagem tiver tamanho impar, recorta a regiao para
  // evitar cÃƒÂ³pias de tamanho desigual
  image = image(Rect(0, 0, image.cols &amp; -2, image.rows &amp; -2));
  int cx = image.cols/2;
  int cy = image.rows/2;

  // reorganiza os quadrantes da transformada
  // A B   -&gt;  D C
  // C D       B A
  A = image(Rect(0, 0, cx, cy));
  B = image(Rect(cx, 0, cx, cy));
  C = image(Rect(0, cy, cx, cy));
  D = image(Rect(cx, cy, cx, cy));

  // A &lt;-&gt; D
  A.copyTo(tmp);  D.copyTo(A);  tmp.copyTo(D);

  // C &lt;-&gt; B
  C.copyTo(tmp);  B.copyTo(C);  tmp.copyTo(B);
}

int main(int argc , char** argv){
  VideoCapture cap;
  Mat imaginaryInput, complexImage, multsp;
  Mat padded, mag;
  Mat image, imagegray;
  Mat_&lt;float&gt; realInput, zeros;
  vector&lt;Mat&gt; planos;

  // guarda tecla capturada
  char key;
	if(argc != 2){
		printf("ERRO\n");
		exit(-1);
	}
	image = imread(argv[1],CV_LOAD_IMAGE_GRAYSCALE); // carrega a imagem

	cv::log(realInput, realInput);
  // identifica os tamanhos otimos para calculo da FFT
  dft_M = getOptimalDFTSize(image.rows);
  dft_N = getOptimalDFTSize(image.cols);

  // realiza o padding da imagem
  copyMakeBorder(image, padded, 0,
                 dft_M - image.rows, 0,
                 dft_N - image.cols,
                 BORDER_CONSTANT, Scalar::all(0));

  // parte imaginaria da matriz complexa (preenchida com zeros)
  zeros = Mat_&lt;float&gt;::zeros(padded.size());

  // prepara a matriz complexa para ser preenchida
  complexImage = Mat(padded.size(), CV_32FC2, Scalar(0));

  filter = complexImage.clone();
	slider(1,0);

  for(;;){

    planos.clear();

    realInput = Mat_&lt;float&gt;(padded);

    planos.push_back(realInput);
    planos.push_back(zeros);

    merge(planos, complexImage);

    dft(complexImage, complexImage);

    deslocaDFT(complexImage);

    mulSpectrums(complexImage,filter,complexImage,0);

    deslocaDFT(complexImage);

    idft(complexImage, complexImage);

    planos.clear();


    split(complexImage, planos);


    normalize(planos[0], planos[0], 0, 1, CV_MINMAX);
		// calcula a exponencial da imagem
		cv::exp(planos[0], planos[0]);

    normalize(planos[0], planos[0], 0, 1, CV_MINMAX);
    imshow("filtrada", planos[0]);

		key = (char) waitKey(10);
    if( key == 27 ) break; // esc pressed!

  	sprintf( TrackbarName, "H %d", dh_slider_max/10);
  	createTrackbar( TrackbarName, "filtrada",
				  &amp;dh_slider,
				  dh_slider_max,
				  NULL); //funcao

		sprintf( TrackbarName, "L %d", dl_slider_max/10);
  	createTrackbar( TrackbarName, "filtrada",
				  &amp;dl_slider,
				  dl_slider_max,
				  NULL); //funcao

		sprintf( TrackbarName, "C %d", c_slider_max/10);
  	createTrackbar( TrackbarName, "filtrada",
				  &amp;c_slider,
				  c_slider_max,
				  NULL); //funcao

		sprintf( TrackbarName, "D0 %d", d0_slider_max/10);
  	createTrackbar( TrackbarName, "filtrada",
				  &amp;d0_slider,
				  d0_slider_max,
				  NULL); //funcao

		slider(d0_slider,0);
  }
  return 0;
}</pre>
</div>
</div>
<div class="paragraph text-left">
<p>Abaixo mostramos a imagem original e ao lado a imagem com o filtro homomórfico aplicado.</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="homomorficFilter.png" alt="1000" width="10000">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_11_1_exercÍcio">11.1 - EXERCÍCIO:</h3>
<div class="ulist text-left">
<ul>
<li>
<p>Utilizando os programas exemplos/canny.cpp e exemplos/pontilhismo.cpp como referência, implemente um programa cannypoints.cpp.
A idéia é usar as bordas produzidas pelo algoritmo de Canny para melhorar a qualidade da imagem pontilhista gerada. A forma como a informação de borda será usada é livre. Entretanto, são apresentadas algumas sugestões de técnicas que poderiam ser utilizadas:</p>
<div class="ulist">
<ul>
<li>
<p>Desenhar pontos grandes na imagem pontilhista básica;</p>
</li>
<li>
<p>Usar a posição dos pixels de borda encontrados pelo algoritmo de Canny para desenhar pontos nos respectivos locais na imagem gerada.</p>
</li>
<li>
<p>Experimente ir aumentando os limiares do algoritmo de Canny e, para cada novo par de limiares, desenhar círculos cada vez menores nas posições encontradas. A Figura Pontilhismo aplicado à imagem Lena foi desenvolvida usando essa técnica.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Escolha uma imagem de seu gosto e aplique a técnica que você desenvolveu.</p>
</li>
<li>
<p>Descreva no seu relatório detalhes do procedimento usado para criar sua técnica pontilhista.</p>
</li>
</ul>
</div>
</div>
<div class="sect2 text-center">
<h3 id="_soluÇÃo_8">SOLUÇÃO:</h3>
<div class="paragraph text-left">
<p>O algoritmo de Canny de fato é útil para diversas aplicações em processamento de imagens e visão artificial. Informações de bordas podem ser usadas para melhorar algoritmos de segmentação automática ou para encontrar objetos em cenas e pontos de interesse. O pontilhismo é uma técnica de desenho impressionista onde o quadro é pintado usando apenas pontos.</p>
</div>
<div class="paragraph text-left">
<p>Nesta atividade o objetivo era o desenvolvimento do filtro de Canny para gerar uma imagem com pontilhismo. Em que inicialmente foi aplicado na imagem o processo do pontilhismo, e em seguida, a imagem bruta passou por algumas iterações do filtro de Canny, para que fosse possível delimitar suas bordas. Em cada uma das iterações o limiar do filtro é alterado com a intenção de obter uma imagem com menos bordas. Para as bordas ficarem mais destacadas foi necessário percorrer a imagem filtrada e desenhar um círculo em cada pixel que possuísse um tom de cinza maior que zero. E como saída é gereda e salva duas imagens editadas, onde a primeira(Imagem pontilhista.jpg) é a imagem com efeito de pontilhismo aplicado.</p>
</div>
<div class="listingblock text-left">
<div class="title">cannypoints.cpp</div>
<div class="content">
<pre>  #include &lt;iostream&gt;
  #include &lt;opencv2/opencv.hpp&gt;
  #include &lt;fstream&gt;
  #include &lt;iomanip&gt;
  #include &lt;vector&gt;
  #include &lt;algorithm&gt;
  #include &lt;numeric&gt;
  #include &lt;ctime&gt;
  #include &lt;cstdlib&gt;

  using namespace std;
  using namespace cv;

  #define STEP 5
  #define JITTER 3
  #define RAIO 5

  int main(int argc, char** argv){
  Mat Original, borderOriginalImage;
  Mat Pontilhismo;
  int x, y, width, height, gray;
  //arrays de índices que servirão para identificar elementos da imagem de referência
  vector&lt;int&gt; yrange;
  vector&lt;int&gt; xrange;

  srand(time(0));

  Original= imread("imagem.jpg" ,CV_LOAD_IMAGE_GRAYSCALE);

  width = Original.size().width;
  height = Original.size().height;
  xrange.resize(height/STEP);
  yrange.resize(width/STEP);
  iota(xrange.begin(), xrange.end(), 0);
  iota(yrange.begin(), yrange.end(), 0);

  for(uint i=0; i&lt;xrange.size(); i++){
    xrange[i]= xrange[i]*STEP+STEP/2;
  }

  for(uint i=0; i&lt;yrange.size(); i++){
    yrange[i]= yrange[i]*STEP+STEP/2;
  }

  Original.copyTo(Pontilhismo);

  //Executa o pontilhismo;
  for(auto i : xrange){
    random_shuffle(yrange.begin(), yrange.end());
    for(auto j : yrange){
      x = i+rand()%(2*JITTER)-JITTER+1;
      y = j+rand()%(2*JITTER)-JITTER+1;
      gray = Original.at&lt;uchar&gt;(x,y);
      circle(Pontilhismo, cv::Point(y,x), RAIO, CV_RGB(gray,gray,gray), -1, CV_AA);
    }
  }

  imshow("Imagem Pontilhista", Pontilhismo);
  imwrite("imagemComPontilhismo.jpg", Pontilhismo);

   //Aplica Canny
   for(int z=0; z&lt;5; z++){
     Canny(Original, borderOriginalImage, 10*z, 50*z);
     int raio = 5-z;

     for(int i=0; i&lt;height; i++ ){
        for(int j=0; j&lt;width; j++){
           if(borderOriginalImage.at&lt;uchar&gt;(i,j) == 255){
              gray = Original.at&lt;uchar&gt;(i,j);
              circle(Pontilhismo, cv::Point(j,i), raio, CV_RGB(gray,gray,gray), -1, CV_AA);
             }
        }
    }


  }
  imshow("Pontilhismo", Pontilhismo);
  imwrite("imagemComPontilhismo.jpg", Pontilhismo);


   waitKey();
  return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>Para esta aplicação foi utilizada como entrada, a imagem abaixo:</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="imagem.jpg" alt="500" width="500">
</div>
<div class="title">Figure 1. Imagem de entrada para aplicação do algoritmo</div>
</div>
<div class="paragraph">
<p>E como saída foi obtida a imagem abaixo:</p>
</div>
<div class="imageblock" style="text-align: center;float: center">
<div class="content">
<img src="resultadocanny.png" alt="1000" width="10000">
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2017-07-01 21:24:05 BRT
</div>
</div>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>